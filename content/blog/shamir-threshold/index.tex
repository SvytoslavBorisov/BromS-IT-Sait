---
title: "Как поделить секрет: простая (k, n) схема Шамира"
description: "Перевод ключевого фрагмента статьи А. Шамира (CACM, 1979) плюс понятные формулы и минимальная реализация на Python."
date: "2025-08-23"
tags:
  - Криптография
  - Пороговые схемы
  - Shamir Secret Sharing
  - Интерполяция Лагранжа
cover: "/blog/shamir-threshold/cover.png"
license: "© Автор перевода, 2025. Non-commercial."
source:
  title: "Adi Shamir — How to Share a Secret (CACM, 1979)"
  doi: "10.1145/359168.359176"
  url: "https://doi.org/10.1145/359168.359176"
  type: "translation"
---

\documentclass[a4paper,12pt]{article}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath,amssymb}
\usepackage{geometry}
\geometry{margin=2.5cm}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{listings}

% Настройки выделения заголовков
\titleformat{\section}{\large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection}{1em}{}

% Настройки листингов (Python)
\lstdefinestyle{py}{
  language=Python,
  basicstyle=\ttfamily\small,
  keywordstyle=\bfseries\color{teal!60!black},
  commentstyle=\itshape\color{gray!70!black},
  stringstyle=\color{orange!60!black},
  showstringspaces=false,
  columns=fullflexible,
  breaklines=true,
  frame=single,
  framerule=0.4pt,
  rulecolor=\color{gray!40},
  backgroundcolor=\color{gray!5},
  tabsize=2
}

\begin{document}

\begin{center}
{\LARGE \textbf{Как поделить секрет: простая $(k, n)$ схема Шамира}}\\[0.5em]
\emph{Перевод ключевого фрагмента статьи А. Шамира (CACM, 1979) плюс понятные формулы и минимальная реализация на Python.}\\[0.5em]
\small Дата: 23 августа 2025 \quad
Теги: Криптография; Пороговые схемы; Shamir Secret Sharing; Интерполяция Лагранжа.\\[0.25em]
\small Лицензия: © Автор перевода, 2025. Non-commercial.\\[0.25em]
\small Источник: Adi Shamir — How to Share a Secret (CACM, 1979), DOI: \href{https://doi.org/10.1145/359168.359176}{10.1145/359168.359176}.
\end{center}

\vspace{1em}

\subsection*{Пороговые схемы в группах «взаимно подозрительных»}

Пороговые схемы особенно хорошо подходят для ситуаций, когда группе людей с конфликтующими интересами необходимо сотрудничать. Идеально — строить взаимодействие на взаимном согласии, но право вето, которое даёт требование единогласия, может парализовать деятельность группы. Правильно выбирая параметры $k$ и $n$, можно дать достаточно большему большинству право на действие, сохраняя у достаточно крупного меньшинства возможность его заблокировать.

\section*{2. Простая $(k,n)$ пороговая схема}

Идея основана на полиномиальной интерполяции: по заданным $k$ точкам $(x_i, y_i)$ с попарно различными $x_i$ существует ровно один многочлен $q(x)$ степени $k-1$, для которого $q(x_i) = y_i$ для всех $i$. Считаем, что данные $D$ — это число. Чтобы разделить $D$ на $n$ частей, выбираем случайный многочлен степени $k-1$:
\begin{equation*}
q(x)=a_0 + a_1 x + \dots + a_{k-1} x^{k-1},\qquad a_0 = D,
\end{equation*}
и вычисляем $n$ значений
\begin{equation*}
D_1 = q(1),\; D_2 = q(2),\; \dots,\; D_n = q(n)
\quad\text{(все операции по модулю }p\text{)}.
\end{equation*}

По любым $k$ из этих пар $(i, D_i)$ можно восстановить коэффициенты $q(x)$ интерполяцией и затем получить секрет как $q(0)$. Знание лишь $k-1$ значений недостаточно для вычисления $D$.

Чтобы формально обосновать нулевое раскрытие при $k-1$ частях, работаем в поле по модулю простого $p$. Берём $p$ больше, чем $D$ и $n$; коэффициенты $a_1,\dots,a_{k-1}$ выбираются равновероятно из $\{0,\dots,p-1\}$, значения $D_i \equiv q(i)\pmod p$. Пусть противнику известны $k-1$ частей. Для каждого кандидата $D' \in \{0,\dots,p-1\}$ существует единственный многочлен $q'(x)$ степени $k-1$, который проходит через известные точки и удовлетворяет $q'(0)=D'$. Эти $p$ вариантов равновероятны, значит противник не узнаёт ничего о настоящем $D$.

Эффективные алгоритмы интерполяции имеют сложность $O(n \log^2 n)$, но даже квадратичные приемлемы. Если $D$ велик, его разбивают на блоки и применяют схему к каждому блоку отдельно. Минимально допустимый модуль $p$ должен быть больше $n$ (нужны разные аргументы $x$), на практике берут большое простое.

\subsection*{Свойства схемы}

\begin{enumerate}[label=\arabic*)]
\item Размер каждой доли не больше размера исходных данных (в пределах выбранного $p$).

\item При фиксированном $k$ доли можно динамически добавлять и удалять, участники могут приходить и уходить.

\item Доли можно перевыпускать без смены секрета $D$: генерируется новый случайный $q(x)$ с тем же свободным членом $a_0 = D$. Старые слитые доли не суммируются в угрозу.

\item Можно строить иерархии полномочий: выдать президенту три разных значения $q(x)$, каждому вице‑президенту по два, каждому руководителю по одному — получится $(3,n)$‑порог: подпишут либо любые трое руководителей, либо двое, один из которых вице‑президент, либо один президент.
\end{enumerate}

\subsection*{Лагранжевое восстановление в точке $x=0$}

Пусть есть $k$ попарно различных пар $(x_i, y_i)$ по модулю $p$. Тогда
\begin{equation*}
q(0) \equiv \sum_{i=1}^{k} y_i \, L_i \pmod p,
\qquad
L_i \equiv \prod_{\substack{j=1\\ j\ne i}}^{k} \frac{-x_j}{x_i - x_j} \pmod p.
\end{equation*}

Где $z^{-1}$ — мультипликативная обратная по модулю $p$ (для простого $p$: $z^{p-2}\bmod p$). Делений в формулах нет — они реализуются как умножение на обратный элемент.

\section*{Python: минимальная реализация Shamir (GF($p$))}

Код ниже самодостаточный: генерация долей и восстановление из любой $k$‑подвыборки. Без внешних зависимостей. По умолчанию $p = 2^{521} - 1$ (большое простое).

\begin{lstlisting}[style=py]
from __future__ import annotations
from dataclasses import dataclass
from secrets import randbelow
from typing import List

# Большое простое (Мерсенна), p > n и p > secret
P = (1 << 521) - 1

@dataclass(frozen=True)
class Share:
    x: int  # уникальный идентификатор 1..n
    y: int  # q(x) mod p

def _mod_inv(a: int, p: int) -> int:
    """Обратный по модулю p, где p — простое."""
    return pow(a % p, p - 2, p)

def _eval_poly(coeffs: List[int], x: int, p: int) -> int:
    """Значение q(x) по Горнеру; coeffs[0] = a0 = секрет."""
    res = 0
    for a in reversed(coeffs):  # a_{k-1} ... a0
        res = (res * x + a) % p
    return res

def split_secret(secret: int, k: int, n: int, p: int = P) -> List[Share]:
    """
    Возвращает n долей для секрета secret при пороге k.
    Требования: 0 <= secret < p и n < p.
    """
    if not (0 <= secret < p):
        raise ValueError("secret must be in [0, p)")
    if not (1 <= k <= n < p):
        raise ValueError("require 1 <= k <= n < p")

    # Случайные коэффициенты a1..a_{k-1}; a0 = secret
    coeffs = [secret] + [randbelow(p) for _ in range(k - 1)]
    return [Share(x=i, y=_eval_poly(coeffs, i, p)) for i in range(1, n + 1)]

def recover_secret(shares: List[Share], p: int = P) -> int:
    """
    Восстанавливает q(0) по любой k-подвыборке долей.
    """
    if not shares:
        raise ValueError("need at least one share")

    xs = [s.x for s in shares]
    ys = [s.y for s in shares]
    if len(set(xs)) != len(xs):
        raise ValueError("duplicate x in shares")

    total = 0
    k = len(shares)
    for i in range(k):
        xi, yi = xs[i], ys[i]
        num = 1
        den = 1
        for j in range(k):
            if i == j:
                continue
            xj = xs[j]
            num = (num * (-xj)) % p
            den = (den * (xi - xj)) % p
        li0 = (num * _mod_inv(den, p)) % p
        total = (total + yi * li0) % p
    return total

if __name__ == "__main__":
    secret = 123456789012345678901234567890
    k, n = 3, 5
    shares = split_secret(secret, k, n)
    print("SHARES:", shares)

    subset = [shares[i] for i in (0, 2, 4)]  # любые 3 доли
    rec = recover_secret(subset)
    print("RECOVERED:", rec)
    assert rec == secret
\end{lstlisting}

\end{document}

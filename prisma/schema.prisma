// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}


//
//   MODELS
//

model Account {
  id                 String  @id @default(cuid())
  userId             String
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String? 
  access_token       String?
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String?
  session_state      String?
  oauth_token_secret String?
  oauth_token        String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("accounts")
  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model User {
  id             String    @id @default(cuid())
  name           String?
  surname        String?    @default("")
  patronymic     String?    @default("")
  age            DateTime?  @default(now())
  sex            Sex?       @default(MALE)
  email          String    @unique
  passwordHash   String
  emailVerified  DateTime?
  publicKey      Json?
  image          String?
  phone          String?
  location       String?

  shares         Share[]           @relation("UserShares")

  createdAt      DateTime          @default(now())
  updatedAt      DateTime?         @updatedAt

  recoverySessions RecoverySession[] @relation("RecoveryDealer")
  shareReceipts    ShareReceipt[]    @relation("ReceiptShareholder")
  notification    Notification[]     @relation("userNotification")
  sendReceipts    ShareReceipt[]     @relation("sendReceipts")
  documents       Document[]         @relation("usersDocuments")
  certifications       Certification[]         @relation("userCertificats")
  documentSignSession       documentSignSession[]         @relation("documentSignSessionDealer")
  signatures       Signatures[]         @relation("usersSignatures")
  settings         UserSettings?         @relation()
  companyId       String?   
  company         Company?         @relation("userCompany", fields: [companyId], references: [id])
  positionId      String?         
  position        Position?    @relation("userPosition", fields: [positionId], references: [id])
  departmentId      String?         
  department        Department?    @relation("userDepartment", fields: [departmentId], references: [id])

  accounts       Account[]
  sessions       Session[]

  managerId      String?            // ссылка на руководителя
  manager        User?              @relation("UserHierarchy", fields: [managerId], references: [id])
  reports        User[]             @relation("UserHierarchy")

  messages      ChatMessage[]   @relation("userMessage")

  /// --- Telegram link ---
  telegramId           String?   @unique            // user_id / chat_id из Telegram (храним как строку для совместимости)
  telegramUsername     String?                      // @username (не уникален, может меняться)
  telegramLinkedAt     DateTime?                    // когда привязали аккаунт
  telegramAllowsWrite  Boolean    @default(false)   // согласие "Allow to message" (Login Widget/WebApp)
  telegramPhotoUrl     String?                      // аватар (если нужен в UI)
  telegramLanguageCode String?                      // например "ru" / "en"
  telegramLastAuthAt   DateTime?                    // время последней успешной валидации hash/initData

  @@index([telegramUsername])


    /// Публичный E2E-ключ транспорта (для шифрования долей мне)
  e2ePublicKey    String?  @unique
  e2ePublicKeyAlg String   @default("ECIES-GOST-2012-256") // или что фактически используешь

  // Dealerless DKG
  dkgParticipants  DkgParticipant[]
  dkgCommitments   DkgCommitment[]
  dkgSharesFrom    DkgShareOutbox[]  @relation("dkgSharesFrom")
  dkgSharesTo      DkgShareOutbox[]  @relation("dkgSharesTo")
  dkgReadiness     DkgReady[]
  dkgComplaintsAsAccuser DkgComplaint[] @relation("complaintsAccuser")
  dkgComplaintsAsAccused DkgComplaint[] @relation("complaintsAccused")
   dkgSessionsCreated       DkgSession[]     @relation("DkgSessionCreatedBy")
   DkgRecoveryShare       DkgRecoveryShare[]     @relation("DkgRecoveryShareUser")
   DkgRecoveryParticipant DkgRecoveryParticipant[] @relation("DkgRecoveryParticipantUser")
   DkgRecoverySession DkgRecoverySession[] @relation("DkgRecoverySessionUser")
}

model UserSettings {
  id              String   @id @default(cuid())
  userId          String   @unique
  user            User     @relation(fields: [userId], references: [id])

  twoFactorEnabled Boolean  @default(false)
  notifyByEmail    Boolean  @default(true)
  notifyByTelegram Boolean  @default(false)
  logRetentionDays Int      @default(30)
  autoSessionLogout Int     @default(15)   // минут
  darkMode         Boolean  @default(false)
  language         String   @default("ru")
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@map("verification_tokens")
  @@unique([identifier, token])
}

model ShamirSession {
  id          String    @id @default(cuid())
  title       String?
  dealerId    String
  p           String    @default("")        // пустая строка
  q           String    @default("")
  g           String    @default("")
  commitments Json      @default("[]")      // пустой JSON-массив
  threshold   Int
  createdAt   DateTime  @default(now())
  status      String    @default("")

  type        ShamirSessionStatus @default(CUSTOM)
  publicKey   AsymmetricKey? @relation("asymmetricShareSession")
  shares      Share[]   @relation("SessionShares")
  recoveries  RecoverySession[]
  signatures          Signatures[]         @relation("shamirSessionSignatures")
}

model Share {
  id                    Int             @id @default(autoincrement())
  sessionId             String          @default("")
  userId                String
  x                     String
  ciphertext            Json
  createdAt             DateTime        @default(now())

  // ── Новые поля ────────────────────────────────────────────────────────────

  /// Статус доли (по умолчанию ACTIVE)
  status                ShareStatus     @default(ACTIVE)

  /// Произвольный комментарий
  comment               String          @default("")

  /// Алгоритм шифрования, которым шифровали эту долю
  encryptionAlgorithm   String          @default("RSA-OAEP-SHA256")

  /// Время истечения доли; `null` = неограниченно
  expiresAt             DateTime?       

  // ── Отношения и индексы ────────────────────────────────────────────────────

  session               ShamirSession   @relation("SessionShares", fields: [sessionId], references: [id])
  user                  User            @relation("UserShares",    fields: [userId],    references: [id])

  receipts      ShareReceipt[]    

  @@unique([sessionId, userId], name: "Share_sessionId_userId")
}

model AsymmetricKey {
  /// Уникальный идентификатор записи
  id                   String          @id @default(uuid())
  createdAt            DateTime        @default(now())
  updatedAt            DateTime        @updatedAt

  /// Ссылка на сессию разделения приватного ключа
  privateKeySharingId  String         @unique
  privateKeySharing    ShamirSession  @relation("asymmetricShareSession", fields: [privateKeySharingId], references: [id])

  publicKey            String         @unique

  /// Параметры эллиптической кривой / поля
  p                    String          // простое число модуля поля
  a                    String          // коэффициент a кривой
  b                    String          // коэффициент b кривой
  q                    String          // порядок группы точек ЭК

  /// Генератор G = (xp, yp)
  xp                   String
  yp                   String

  /// Публичный ключ Q = d·G
  Q                    String

  certification       Certification?   @relation("asymmetricKeyCertificate")
  documentSigns documentSignSession[] @relation("publicKeyOfdocumentSign")
}

model RecoverySession {
  id              String   @id @default(cuid())
  dealerId        String
  dealer          User         @relation("RecoveryDealer", fields:[dealerId], references:[id])

  shareSessionId  String
  shareSession    ShamirSession @relation(fields:[shareSessionId], references:[id])

  documentSignSession    documentSignSession[]    @relation("documentSignSessionRecovery")

  status      RecoveryStatus @default(PENDING)
  createdAt   DateTime       @default(now())
  finishedAt  DateTime?

  receipts    ShareReceipt[]
}

model ShareReceipt {
  id             String   @id @default(cuid())
  recoveryId     String
  recovery       RecoverySession @relation(fields:[recoveryId], references:[id])

  shareholderId  String
  shareholder    User            @relation("ReceiptShareholder", fields:[shareholderId], references:[id])

  shareSessionId String  
  share          Share           @relation(fields: [shareSessionId, shareholderId], references: [sessionId, userId])

  status         String
  senderId       String  
  sender         User           @relation("sendReceipts", fields: [senderId], references: [id])

  ciphertext     Json @default("[]")
  receivedAt     DateTime @default(now())
}

model Notification {
  id          String    @id @default(cuid())
  userId      String
  type        String    // e.g. "recover_secret", "message", "alert"
  payload     Json      // любые данные, связанные с уведомлением
  isRead      Boolean   @default(false)
  createdAt   DateTime  @default(now())

  user        User      @relation("userNotification", fields: [userId], references: [id])
}

model Document {
  /// Уникальный идентификатор документа
  id          String    @id @default(cuid())

  /// Кем загружен
  userId      String
  user        User      @relation("usersDocuments", fields: [userId], references: [id], onDelete: Cascade)

  /// Оригинальное имя файла
  fileName    String

  /// MIME-тип (например, "application/pdf")
  fileType    String

  /// Размер в байтах
  fileSize    Int

  /// Где хранится на сервере (абсолютный или относительный путь)
  filePath    String

  /// Произвольное описание или теги
  description String?   @default("")

  /// Дополнительные метаданные (например, превью, EXIF, checksum и т.п.)
  metadata    Json?    @default("{}")

  /// Когда загрузили
  createdAt   DateTime @default(now())

  /// Когда последний раз обновляли (если нужно)
  updatedAt   DateTime @updatedAt

  type        DocumentStatus? @default(NOTECRYPT)

  documentSignSession    documentSignSession[]    @relation("documentIdSignSession")
  documentSignatures     Signatures[]    @relation("documentIdSignatures")

  @@map("documents")
  @@index([userId, createdAt])
}

model documentSignSession {
  id          String    @id @default(cuid())
  dealerId        String
  dealer          User         @relation("documentSignSessionDealer", fields:[dealerId], references:[id])

  hash String?

  publicKeyId String?
  publicKey  AsymmetricKey?         @relation("publicKeyOfdocumentSign", fields:[publicKeyId], references:[id])
  r String?  @default("")
  s String?  @default("")

  documentId        String
  document          Document         @relation("documentIdSignSession", fields:[documentId], references:[id])

  status RecoveryStatus @default(PENDING)
  recoveryId String @unique
  recovery RecoverySession @relation("documentSignSessionRecovery", fields:[recoveryId], references:[id])
}

model Signatures {
  id          String    @id @default(cuid())
  filePath    String?     // если присоединенная то храним как файла
  pem         String?
  type        String

  path        String?

  documentId        String?
  document          Document?         @relation("documentIdSignatures", fields:[documentId], references:[id])

  userId      String
  user        User      @relation("usersSignatures", fields: [userId], references: [id])

  shamirSessionId        String?
  shamirSession          ShamirSession?         @relation("shamirSessionSignatures", fields:[shamirSessionId], references:[id])
}

model Company {
  id          String    @id @default(cuid())
  title       String    @default("Компания")
  email       String    @unique
  image       String?

  user        User[]    @relation("userCompany")
  positions   Position[]  @relation("companyPositions")
  departments   Department[]  @relation("departmentCompany")
}

model Department {
  id          String    @id @default(cuid())
  title       String    @default("Отдел")
  email       String    @unique

  user        User[]    @relation("userDepartment")
  companyId   String
  company     Company   @relation("departmentCompany", fields: [companyId], references: [id])
}

model Position {
  id          String    @id @default(cuid())
  title       String    @default("Должность")
  
  companyId   String
  company     Company   @relation("companyPositions", fields: [companyId], references: [id])

  user        User[]    @relation("userPosition")

  rank        Int       @default(100)
}

model Certification {
  id          String    @id @default(cuid())
  title       String    @default("Сертификат")

  ownerId     String
  owner       User   @relation("userCertificats", fields: [ownerId], references: [id])

  pem         String

  asymmetricKeyId     String? @unique
  asymmetricKey       AsymmetricKey?   @relation("asymmetricKeyCertificate", fields: [asymmetricKeyId], references: [id])

    /// Когда загрузили
  createdAt   DateTime @default(now())

  /// Когда последний раз обновляли (если нужно)
  updatedAt   DateTime @updatedAt
}

model ChatMessage {
  id        String   @id @default(cuid())
  room      String
  text      String
  userId    String
  user      User   @relation("userMessage", fields: [userId], references: [id])
  ts        DateTime @default(now())
  // @@index([room, ts])
}


model DkgSession {
  id          String           @id @default(cuid())
  title       String?          @default("")
  n           Int
  t           Int
  epoch       String           @default("2025Q3")
  status      DkgSessionStatus @default(LOBBY)

  createdById String?
  createdBy   User? @relation("DkgSessionCreatedBy", fields: [createdById], references: [id])

  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  participants  DkgParticipant[]
  commitments   DkgCommitment[]
  shares        DkgShareOutbox[]
  readiness     DkgReady[]
  complaints    DkgComplaint[]

  DkgRecoverySession DkgRecoverySession[] @relation("DkgRecoverySessionDkgSession")

  @@index([status, createdAt])
}

model DkgParticipant {
  id         String     @id @default(cuid())
  sessionId  String
  session    DkgSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  userId     String
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  // дублируем на момент входа — чтобы участник мог поменять ключ позже, а сессия осталась консистентной
  e2ePublicKey    String
  e2ePublicKeyAlg String   @default("ECIES-GOST-2012-256")

  isHost     Boolean    @default(false)
  joinedAt   DateTime   @default(now())
  leftAt     DateTime?

  @@unique([sessionId, userId])
  @@index([sessionId])
}

model DkgCommitment {
  id         String     @id @default(cuid())
  sessionId  String
  session    DkgSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  fromUserId String
  fromUser   User       @relation(fields: [fromUserId], references: [id], onDelete: Cascade)

  // массив точек C_k = a_k*G (храним как JSON: [{x:"hex", y:"hex"}, ...])
  commitments Json
  // опционально: хеш сериализации коммитментов, чтобы быстро сверять
  commitmentsHash String

  // подпись отправителя коммитментов (формат на твоё усмотрение: hex/base64)
  signature  String

  createdAt  DateTime   @default(now())

  @@unique([sessionId, fromUserId]) // один набор на участника в сессии
  @@index([sessionId])
}

model DkgShareOutbox {
  id         String     @id @default(cuid())
  sessionId  String
  session    DkgSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  fromUserId String
  fromUser   User       @relation("dkgSharesFrom", fields: [fromUserId], references: [id], onDelete: Cascade)

  toUserId   String
  toUser     User       @relation("dkgSharesTo", fields: [toUserId], references: [id], onDelete: Cascade)

  // шифртекст персональной доли s_{from->to} (ECIES на e2ePublicKey получателя)
  ciphertext Bytes
  // AAD/transcript hash, чтобы исключить replay между сессиями
  transcriptHash String

  // подпись метаданных отправителем (identity-подпись)
  signature  String

  status     DkgShareDelivery @default(SENT)
  createdAt  DateTime         @default(now())
  deliveredAt DateTime?
  readAt     DateTime?

  @@unique([sessionId, fromUserId, toUserId]) // не дублируем
  @@index([sessionId, toUserId, status])
}

model DkgReady {
  id         String     @id @default(cuid())
  sessionId  String
  session    DkgSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  userId     String
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  // хеш публичного ключа Q (например, H(ser(Q)))
  Qhash      String

  // опционально: хеш всего транскрипта (для аудита)
  transcriptHash String

  createdAt  DateTime   @default(now())

  @@unique([sessionId, userId])
  @@index([sessionId])
}

model DkgComplaint {
  id         String     @id @default(cuid())
  sessionId  String
  session    DkgSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  // кто жалуется и на кого
  accuserId  String
  accuser    User       @relation("complaintsAccuser", fields: [accuserId], references: [id], onDelete: Cascade)

  accusedId  String
  accused    User       @relation("complaintsAccused", fields: [accusedId], references: [id], onDelete: Cascade)

  // произвольное описание/тип
  reason     String      @default("")

  // полезная нагрузка (например: раскрытая спорная доля, индексы, пруфы)
  payload    Json

  status     DkgComplaintStatus @default(OPEN)
  createdAt  DateTime           @default(now())
  resolvedAt DateTime?

  @@index([sessionId, status])
}


//
//   ENUMS
//

enum RecoveryStatus {
  PENDING
  DONE
  CANCELED
}

enum ShareStatus {
  ACTIVE
  USED
  EXPIRED
  // при необходимости можно добавить и другие состояния
}

enum DocumentStatus {
  NOTECRYPT
  ECRYPT
}

enum ShamirSessionStatus {
  CUSTOM
  ASYMMETRIC
}

enum Sex {
  MALE
  FEMALE
}

enum DkgSessionStatus {
  LOBBY    // лобби: ждём N из N
  ROUND1   // публикация коммитментов
  ROUND2   // обмен зашифрованными долями
  ROUND3   // проверка и финал
  FINAL    // завершено успешно
  ABORTED  // остановлено/оспорено
}

enum DkgShareDelivery {
  SENT
  DELIVERED
  READ
  REJECTED
}

enum DkgComplaintStatus {
  OPEN
  RESOLVED
  REJECTED
}

enum DkgRecoveryStatus {
  OPEN
  VERIFYING
  DONE
  FAILED
}

model DkgRecoverySession {
  id               String            @id @default(cuid())
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt

  // источник — исходная DKG-сессия
  sourceSessionId  String
  sourceSession    DkgSession        @relation("DkgRecoverySessionDkgSession", fields: [sourceSessionId], references: [id], onDelete: Cascade)

  // инварианты/контекст для связывания
  qHash            String            // H(ser(Q)) из исходной сессии
  n                Int
  t                Int
  epoch            String

  // кто запросил восстановление (кому отдадим зашифрованный результат)
  requesterUserId  String
  requester        User              @relation("DkgRecoverySessionUser", fields: [requesterUserId], references: [id], onDelete: Cascade)
  requesterPubKey  String            // hex; ECIES-ключ транспорта

  status           DkgRecoveryStatus @default(OPEN)

  // финальный результат (только зашифрованный артефакт)
  resultCiphertext String?
  resultMeta       String?

  participants     DkgRecoveryParticipant[]
  shares           DkgRecoveryShare[]

  @@index([sourceSessionId, status, createdAt])
}

model DkgRecoveryParticipant {
  id          String             @id @default(cuid())
  joinedAt    DateTime           @default(now())

  recoveryId  String
  recovery    DkgRecoverySession @relation(fields: [recoveryId], references: [id], onDelete: Cascade)

  userId      String
  user        User               @relation("DkgRecoveryParticipantUser", fields: [userId], references: [id], onDelete: Cascade)

  e2ePublicKey String?           // для удобства (дублируем, как в DkgParticipant)

  @@unique([recoveryId, userId])
  @@index([recoveryId])
}

model DkgRecoveryShare {
  id          String             @id @default(cuid())
  createdAt   DateTime           @default(now())

  recoveryId  String
  recovery    DkgRecoverySession @relation(fields: [recoveryId], references: [id], onDelete: Cascade)

  fromUserId  String
  fromUser    User               @relation("DkgRecoveryShareUser", fields: [fromUserId], references: [id], onDelete: Cascade)

  // итоговая доля sᵢ участника i (hex, BE). Проверяем по агрегированным коммитментам.
  s_i_hex     String
  proofOk     Boolean            @default(false)
  note        String             @default("")

  @@unique([recoveryId, fromUserId])
  @@index([recoveryId])
}
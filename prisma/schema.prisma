// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}


//
//   MODELS
//

model Account {
  id                 String  @id @default(cuid())
  userId             String
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String? 
  access_token       String?
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String?
  session_state      String?
  oauth_token_secret String?
  oauth_token        String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("accounts")
  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model User {
  id             String    @id @default(cuid())
  name           String?
  surname        String?    @default("")
  patronymic     String?    @default("")
  age            DateTime?  @default(now())
  sex            Sex?       @default(MALE)
  email          String    @unique
  passwordHash   String
  emailVerified  DateTime?
  publicKey      Json?
  image          String?

  shares         Share[]           @relation("UserShares")

  createdAt      DateTime          @default(now())
  updatedAt      DateTime?         @updatedAt

  recoverySessions RecoverySession[] @relation("RecoveryDealer")
  shareReceipts    ShareReceipt[]    @relation("ReceiptShareholder")
  notification    Notification[]     @relation("userNotification")
  sendReceipts    ShareReceipt[]     @relation("sendReceipts")
  documents       Document[]         @relation("usersDocuments")
  certifications       Certification[]         @relation("userCertificats")
  documentSignSession       documentSignSession[]         @relation("documentSignSessionDealer")
  signatures       Signatures[]         @relation("usersSignatures")
  settings         UserSettings?         @relation()
  companyId       String?   
  company         Company?         @relation("userCompany", fields: [companyId], references: [id])
  positionId      String?         
  position        Position?    @relation("userPosition", fields: [positionId], references: [id])
  departmentId      String?         
  department        Department?    @relation("userDepartment", fields: [departmentId], references: [id])

  accounts       Account[]
  sessions       Session[]

  managerId      String?            // ссылка на руководителя
  manager        User?              @relation("UserHierarchy", fields: [managerId], references: [id])
  reports        User[]             @relation("UserHierarchy")
}

model UserSettings {
  id              String   @id @default(cuid())
  userId          String   @unique
  user            User     @relation(fields: [userId], references: [id])

  twoFactorEnabled Boolean  @default(false)
  notifyByEmail    Boolean  @default(true)
  notifyByTelegram Boolean  @default(false)
  logRetentionDays Int      @default(30)
  autoSessionLogout Int     @default(15)   // минут
  darkMode         Boolean  @default(false)
  language         String   @default("ru")
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@map("verification_tokens")
  @@unique([identifier, token])
}

model ShamirSession {
  id          String    @id @default(cuid())
  title       String?
  dealerId    String
  p           String    @default("")        // пустая строка
  q           String    @default("")
  g           String    @default("")
  commitments Json      @default("[]")      // пустой JSON-массив
  threshold   Int
  createdAt   DateTime  @default(now())
  status      String    @default("")

  type        ShamirSessionStatus @default(CUSTOM)
  publicKey   AsymmetricKey? @relation("asymmetricShareSession")
  shares      Share[]   @relation("SessionShares")
  recoveries  RecoverySession[]
}

model Share {
  id                    Int             @id @default(autoincrement())
  sessionId             String          @default("")
  userId                String
  x                     String
  ciphertext            Json
  createdAt             DateTime        @default(now())

  // ── Новые поля ────────────────────────────────────────────────────────────

  /// Статус доли (по умолчанию ACTIVE)
  status                ShareStatus     @default(ACTIVE)

  /// Произвольный комментарий
  comment               String          @default("")

  /// Алгоритм шифрования, которым шифровали эту долю
  encryptionAlgorithm   String          @default("RSA-OAEP-SHA256")

  /// Время истечения доли; `null` = неограниченно
  expiresAt             DateTime?       

  // ── Отношения и индексы ────────────────────────────────────────────────────

  session               ShamirSession   @relation("SessionShares", fields: [sessionId], references: [id])
  user                  User            @relation("UserShares",    fields: [userId],    references: [id])

  receipts      ShareReceipt[]    

  @@unique([sessionId, userId], name: "Share_sessionId_userId")
}

model AsymmetricKey {
  /// Уникальный идентификатор записи
  id                   String          @id @default(uuid())
  createdAt            DateTime        @default(now())
  updatedAt            DateTime        @updatedAt

  /// Ссылка на сессию разделения приватного ключа
  privateKeySharingId  String         @unique
  privateKeySharing    ShamirSession  @relation("asymmetricShareSession", fields: [privateKeySharingId], references: [id])

  publicKey            String         @unique

  /// Параметры эллиптической кривой / поля
  p                    String          // простое число модуля поля
  a                    String          // коэффициент a кривой
  b                    String          // коэффициент b кривой
  q                    String          // порядок группы точек ЭК

  /// Генератор G = (xp, yp)
  xp                   String
  yp                   String

  /// Публичный ключ Q = d·G
  Q                    String

  certification       Certification?   @relation("asymmetricKeyCertificate")
  documentSigns documentSignSession[] @relation("publicKeyOfdocumentSign")
}

model RecoverySession {
  id              String   @id @default(cuid())
  dealerId        String
  dealer          User         @relation("RecoveryDealer", fields:[dealerId], references:[id])

  shareSessionId  String
  shareSession    ShamirSession @relation(fields:[shareSessionId], references:[id])

  documentSignSession    documentSignSession[]    @relation("documentSignSessionRecovery")

  status      RecoveryStatus @default(PENDING)
  createdAt   DateTime       @default(now())
  finishedAt  DateTime?

  receipts    ShareReceipt[]
}

model ShareReceipt {
  id             String   @id @default(cuid())
  recoveryId     String
  recovery       RecoverySession @relation(fields:[recoveryId], references:[id])

  shareholderId  String
  shareholder    User            @relation("ReceiptShareholder", fields:[shareholderId], references:[id])

  shareSessionId String  
  share          Share           @relation(fields: [shareSessionId, shareholderId], references: [sessionId, userId])

  status         String
  senderId       String  
  sender         User           @relation("sendReceipts", fields: [senderId], references: [id])

  ciphertext     Json @default("[]")
  receivedAt     DateTime @default(now())
}

model Notification {
  id          String    @id @default(cuid())
  userId      String
  type        String    // e.g. "recover_secret", "message", "alert"
  payload     Json      // любые данные, связанные с уведомлением
  isRead      Boolean   @default(false)
  createdAt   DateTime  @default(now())

  user        User      @relation("userNotification", fields: [userId], references: [id])
}

model Document {
  /// Уникальный идентификатор документа
  id          String    @id @default(cuid())

  /// Кем загружен
  userId      String
  user        User      @relation("usersDocuments", fields: [userId], references: [id], onDelete: Cascade)

  /// Оригинальное имя файла
  fileName    String

  /// MIME-тип (например, "application/pdf")
  fileType    String

  /// Размер в байтах
  fileSize    Int

  /// Где хранится на сервере (абсолютный или относительный путь)
  filePath    String

  /// Произвольное описание или теги
  description String?   @default("")

  /// Дополнительные метаданные (например, превью, EXIF, checksum и т.п.)
  metadata    Json?    @default("{}")

  /// Когда загрузили
  createdAt   DateTime @default(now())

  /// Когда последний раз обновляли (если нужно)
  updatedAt   DateTime @updatedAt

  type        DocumentStatus? @default(NOTECRYPT)

  documentSignSession    documentSignSession[]    @relation("documentIdSignSession")
  documentSignatures     Signatures[]    @relation("documentIdSignatures")

  @@map("documents")
  @@index([userId, createdAt])
}

model documentSignSession {
  id          String    @id @default(cuid())
  dealerId        String
  dealer          User         @relation("documentSignSessionDealer", fields:[dealerId], references:[id])

  hash String?

  publicKeyId String?
  publicKey  AsymmetricKey?         @relation("publicKeyOfdocumentSign", fields:[publicKeyId], references:[id])
  r String?  @default("")
  s String?  @default("")

  documentId        String
  document          Document         @relation("documentIdSignSession", fields:[documentId], references:[id])

  status RecoveryStatus @default(PENDING)
  recoveryId String @unique
  recovery RecoverySession @relation("documentSignSessionRecovery", fields:[recoveryId], references:[id])
}

model Signatures {
  id          String    @id @default(cuid())

  documentId        String
  document          Document         @relation("documentIdSignatures", fields:[documentId], references:[id])

  userId      String
  user        User      @relation("usersSignatures", fields: [userId], references: [id])
}

model Company {
  id          String    @id @default(cuid())
  title       String    @default("Компания")
  email       String    @unique
  image       String?

  user        User[]    @relation("userCompany")
  positions   Position[]  @relation("companyPositions")
  departments   Department[]  @relation("departmentCompany")
}

model Department {
  id          String    @id @default(cuid())
  title       String    @default("Отдел")
  email       String    @unique

  user        User[]    @relation("userDepartment")
  companyId   String
  company     Company   @relation("departmentCompany", fields: [companyId], references: [id])
}

model Position {
  id          String    @id @default(cuid())
  title       String    @default("Должность")
  
  companyId   String
  company     Company   @relation("companyPositions", fields: [companyId], references: [id])

  user        User[]    @relation("userPosition")

  rank        Int       @default(100)
}

model Certification {
  id          String    @id @default(cuid())
  title       String    @default("Сертификат")

  ownerId     String
  owner       User   @relation("userCertificats", fields: [ownerId], references: [id])

  pem         String

  asymmetricKeyId     String? @unique
  asymmetricKey       AsymmetricKey?   @relation("asymmetricKeyCertificate", fields: [asymmetricKeyId], references: [id])

    /// Когда загрузили
  createdAt   DateTime @default(now())

  /// Когда последний раз обновляли (если нужно)
  updatedAt   DateTime @updatedAt
}


//
//   ENUMS
//

enum RecoveryStatus {
  PENDING
  DONE
  CANCELED
}

enum ShareStatus {
  ACTIVE
  USED
  EXPIRED
  // при необходимости можно добавить и другие состояния
}

enum DocumentStatus {
  NOTECRYPT
  ECRYPT
}

enum ShamirSessionStatus {
  CUSTOM
  ASYMMETRIC
}

enum Sex {
  MALE
  FEMALE
}
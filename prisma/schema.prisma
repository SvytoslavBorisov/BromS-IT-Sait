generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

model Account {
  id                 String  @id @default(cuid())
  userId             String
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String?
  access_token       String?
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String?
  session_state      String?
  oauth_token_secret String?
  oauth_token        String?
  user               User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model User {
  id                     String                   @id @default(cuid())
  name                   String?
  surname                String?                  @default("")
  patronymic             String?                  @default("")
  age                    DateTime?                @default(now())
  sex                    Sex?                     @default(MALE)
  email                  String                   @unique
  passwordHash           String
  emailVerified          DateTime?
  publicKey              Json?
  image                  String?
  phone                  String?
  location               String?
  createdAt              DateTime                 @default(now())
  updatedAt              DateTime?                @updatedAt
  companyId              String?
  positionId             String?
  departmentId           String?
  managerId              String?
  /// --- Telegram link ---
  telegramId             String?                  @unique
  telegramUsername       String?
  telegramLinkedAt       DateTime?
  telegramAllowsWrite    Boolean                  @default(false)
  telegramPhotoUrl       String?
  telegramLanguageCode   String?
  telegramLastAuthAt     DateTime?
  /// Публичный E2E-ключ транспорта (для шифрования долей мне)
  e2ePublicKey           String?                  @unique
  e2ePublicKeyAlg        String                   @default("ECIES-GOST-2012-256")
  certifications         Certification[]          @relation("userCertificats")
  messages               ChatMessage[]            @relation("userMessage")
  dkgCommitments         DkgCommitment[]
  dkgComplaintsAsAccused DkgComplaint[]           @relation("complaintsAccused")
  dkgComplaintsAsAccuser DkgComplaint[]           @relation("complaintsAccuser")
  dkgParticipants        DkgParticipant[]
  dkgReadiness           DkgReady[]
  DkgRecoveryParticipant DkgRecoveryParticipant[] @relation("DkgRecoveryParticipantUser")
  DkgRecoverySession     DkgRecoverySession[]     @relation("DkgRecoverySessionUser")
  DkgRecoveryShare       DkgRecoveryShare[]       @relation("DkgRecoveryShareUser")
  dkgSessionsCreated     DkgSession[]             @relation("DkgSessionCreatedBy")
  dkgSharesFrom          DkgShareOutbox[]         @relation("dkgSharesFrom")
  dkgSharesTo            DkgShareOutbox[]         @relation("dkgSharesTo")
  notification           Notification[]           @relation("userNotification")
  recoverySessions       RecoverySession[]        @relation("RecoveryDealer")
  shares                 Share[]                  @relation("UserShares")
  sendReceipts           ShareReceipt[]           @relation("sendReceipts")
  shareReceipts          ShareReceipt[]           @relation("ReceiptShareholder")
  signatures             Signatures[]             @relation("usersSignatures")
  company                Company?                 @relation("userCompany", fields: [companyId], references: [id])
  department             Department?              @relation("userDepartment", fields: [departmentId], references: [id])
  manager                User?                    @relation("UserHierarchy", fields: [managerId], references: [id])
  reports                User[]                   @relation("UserHierarchy")
  position               Position?                @relation("userPosition", fields: [positionId], references: [id])
  settings               UserSettings?
  accounts               Account[]
  documentSignSession    documentSignSession[]    @relation("documentSignSessionDealer")
  documents              Document[]               @relation("usersDocuments")
  sessions               Session[]

  @@index([telegramUsername])
}

model UserSettings {
  userId            String   @unique
  autoSessionLogout Int      @default(15)
  createdAt         DateTime @default(now())
  darkMode          Boolean  @default(false)
  id                String   @id @default(cuid())
  language          String   @default("ru")
  logRetentionDays  Int      @default(30)
  notifyByEmail     Boolean  @default(true)
  notifyByTelegram  Boolean  @default(false)
  twoFactorEnabled  Boolean  @default(false)
  updatedAt         DateTime @updatedAt
  user              User     @relation(fields: [userId], references: [id])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model ShamirSession {
  id          String              @id @default(cuid())
  dealerId    String
  threshold   Int
  createdAt   DateTime            @default(now())
  commitments Json                @default("[]")
  g           String              @default("")
  p           String              @default("")
  q           String              @default("")
  status      String              @default("")
  title       String?
  type        ShamirSessionStatus @default(CUSTOM)
  publicKey   AsymmetricKey?      @relation("asymmetricShareSession")
  recoveries  RecoverySession[]
  shares      Share[]             @relation("SessionShares")
  signatures  Signatures[]        @relation("shamirSessionSignatures")
}

model Share {
  id                  Int            @id @default(autoincrement())
  userId              String
  x                   String
  ciphertext          Json
  createdAt           DateTime       @default(now())
  sessionId           String         @default("")
  /// Произвольный комментарий
  comment             String         @default("")
  /// Алгоритм шифрования, которым шифровали эту долю
  encryptionAlgorithm String         @default("RSA-OAEP-SHA256")
  /// Время истечения доли; `null` = неограниченно
  expiresAt           DateTime?
  /// Статус доли (по умолчанию ACTIVE)
  status              ShareStatus    @default(ACTIVE)
  session             ShamirSession  @relation("SessionShares", fields: [sessionId], references: [id])
  user                User           @relation("UserShares", fields: [userId], references: [id])
  receipts            ShareReceipt[]

  @@unique([sessionId, userId], name: "Share_sessionId_userId")
}

model AsymmetricKey {
  /// Уникальный идентификатор записи
  id                  String                @id @default(uuid())
  createdAt           DateTime              @default(now())
  updatedAt           DateTime              @updatedAt
  /// Ссылка на сессию разделения приватного ключа
  privateKeySharingId String                @unique
  /// Параметры эллиптической кривой / поля
  p                   String
  a                   String
  b                   String
  q                   String
  /// Генератор G = (xp, yp)
  xp                  String
  yp                  String
  /// Публичный ключ Q = d·G
  Q                   String
  publicKey           String                @unique
  privateKeySharing   ShamirSession         @relation("asymmetricShareSession", fields: [privateKeySharingId], references: [id])
  certification       Certification?        @relation("asymmetricKeyCertificate")
  documentSigns       documentSignSession[] @relation("publicKeyOfdocumentSign")
}

model RecoverySession {
  id                  String               @id @default(cuid())
  dealerId            String
  shareSessionId      String
  status              RecoveryStatus       @default(PENDING)
  createdAt           DateTime             @default(now())
  finishedAt          DateTime?
  dealer              User                 @relation("RecoveryDealer", fields: [dealerId], references: [id])
  shareSession        ShamirSession        @relation(fields: [shareSessionId], references: [id])
  receipts            ShareReceipt[]
  documentSignSession documentSignSession? @relation("documentSignSessionRecovery")
}

model ShareReceipt {
  id             String          @id @default(cuid())
  recoveryId     String
  shareholderId  String
  ciphertext     Json            @default("[]")
  receivedAt     DateTime        @default(now())
  shareSessionId String
  senderId       String
  status         String
  recovery       RecoverySession @relation(fields: [recoveryId], references: [id])
  sender         User            @relation("sendReceipts", fields: [senderId], references: [id])
  share          Share           @relation(fields: [shareSessionId, shareholderId], references: [sessionId, userId])
  shareholder    User            @relation("ReceiptShareholder", fields: [shareholderId], references: [id])
}

model Notification {
  id        String   @id @default(cuid())
  userId    String
  type      String
  payload   Json
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation("userNotification", fields: [userId], references: [id])
}

model Document {
  /// Уникальный идентификатор документа
  id                  String                @id @default(cuid())
  /// Кем загружен
  userId              String
  /// Оригинальное имя файла
  fileName            String
  /// MIME-тип (например, "application/pdf")
  fileType            String
  /// Размер в байтах
  fileSize            Int
  /// Где хранится на сервере (абсолютный или относительный путь)
  filePath            String
  /// Произвольное описание или теги
  description         String?               @default("")
  /// Дополнительные метаданные (например, превью, EXIF, checksum и т.п.)
  metadata            Json?                 @default("{}")
  /// Когда загрузили
  createdAt           DateTime              @default(now())
  /// Когда последний раз обновляли (если нужно)
  updatedAt           DateTime              @updatedAt
  type                DocumentStatus?       @default(NOTECRYPT)
  documentSignatures  Signatures[]          @relation("documentIdSignatures")
  documentSignSession documentSignSession[] @relation("documentIdSignSession")
  user                User                  @relation("usersDocuments", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@map("documents")
}

model documentSignSession {
  id          String          @id @default(cuid())
  dealerId    String
  hash        String?
  documentId  String
  status      RecoveryStatus  @default(PENDING)
  recoveryId  String          @unique
  publicKeyId String?
  r           String?         @default("")
  s           String?         @default("")
  dealer      User            @relation("documentSignSessionDealer", fields: [dealerId], references: [id])
  document    Document        @relation("documentIdSignSession", fields: [documentId], references: [id])
  publicKey   AsymmetricKey?  @relation("publicKeyOfdocumentSign", fields: [publicKeyId], references: [id])
  recovery    RecoverySession @relation("documentSignSessionRecovery", fields: [recoveryId], references: [id])
}

model Signatures {
  id              String         @id @default(cuid())
  documentId      String?
  userId          String
  filePath        String?
  pem             String?
  shamirSessionId String?
  type            String
  path            String?
  document        Document?      @relation("documentIdSignatures", fields: [documentId], references: [id])
  shamirSession   ShamirSession? @relation("shamirSessionSignatures", fields: [shamirSessionId], references: [id])
  user            User           @relation("usersSignatures", fields: [userId], references: [id])
}

model Company {
  id          String       @id @default(cuid())
  title       String       @default("Компания")
  email       String       @unique
  image       String?
  departments Department[] @relation("departmentCompany")
  positions   Position[]   @relation("companyPositions")
  user        User[]       @relation("userCompany")
}

model Department {
  id        String  @id @default(cuid())
  title     String  @default("Отдел")
  email     String  @unique
  companyId String
  company   Company @relation("departmentCompany", fields: [companyId], references: [id])
  user      User[]  @relation("userDepartment")
}

model Position {
  id        String  @id @default(cuid())
  title     String  @default("Должность")
  companyId String
  rank      Int     @default(100)
  company   Company @relation("companyPositions", fields: [companyId], references: [id])
  user      User[]  @relation("userPosition")
}

model Certification {
  id              String         @id @default(cuid())
  title           String         @default("Сертификат")
  ownerId         String
  asymmetricKeyId String?        @unique
  pem             String
  /// Когда загрузили
  createdAt       DateTime       @default(now())
  /// Когда последний раз обновляли (если нужно)
  updatedAt       DateTime       @updatedAt
  asymmetricKey   AsymmetricKey? @relation("asymmetricKeyCertificate", fields: [asymmetricKeyId], references: [id])
  owner           User           @relation("userCertificats", fields: [ownerId], references: [id])
}

model ChatMessage {
  id     String   @id @default(cuid())
  room   String
  text   String
  userId String
  ts     DateTime @default(now())
  user   User     @relation("userMessage", fields: [userId], references: [id])
}

model DkgSession {
  id                 String               @id @default(cuid())
  title              String?              @default("")
  n                  Int
  t                  Int
  epoch              String               @default("2025Q3")
  status             DkgSessionStatus     @default(LOBBY)
  createdById        String?
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt
  commitments        DkgCommitment[]
  complaints         DkgComplaint[]
  participants       DkgParticipant[]
  readiness          DkgReady[]
  DkgRecoverySession DkgRecoverySession[] @relation("DkgRecoverySessionDkgSession")
  createdBy          User?                @relation("DkgSessionCreatedBy", fields: [createdById], references: [id])
  shares             DkgShareOutbox[]

  @@index([status, createdAt])
}

model DkgParticipant {
  id              String     @id @default(cuid())
  sessionId       String
  userId          String
  e2ePublicKey    String
  e2ePublicKeyAlg String     @default("ECIES-GOST-2012-256")
  isHost          Boolean    @default(false)
  joinedAt        DateTime   @default(now())
  leftAt          DateTime?
  session         DkgSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  user            User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([sessionId, userId])
  @@index([sessionId])
}

model DkgCommitment {
  id              String     @id @default(cuid())
  sessionId       String
  fromUserId      String
  commitments     Json
  commitmentsHash String
  signature       String
  createdAt       DateTime   @default(now())
  fromUser        User       @relation(fields: [fromUserId], references: [id], onDelete: Cascade)
  session         DkgSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@unique([sessionId, fromUserId])
  @@index([sessionId])
}

model DkgShareOutbox {
  id             String           @id @default(cuid())
  sessionId      String
  fromUserId     String
  toUserId       String
  ciphertext     Bytes
  transcriptHash String
  signature      String
  status         DkgShareDelivery @default(SENT)
  createdAt      DateTime         @default(now())
  deliveredAt    DateTime?
  readAt         DateTime?
  fromUser       User             @relation("dkgSharesFrom", fields: [fromUserId], references: [id], onDelete: Cascade)
  session        DkgSession       @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  toUser         User             @relation("dkgSharesTo", fields: [toUserId], references: [id], onDelete: Cascade)

  @@unique([sessionId, fromUserId, toUserId])
  @@index([sessionId, toUserId, status])
}

model DkgReady {
  id             String     @id @default(cuid())
  sessionId      String
  userId         String
  Qhash          String
  transcriptHash String
  createdAt      DateTime   @default(now())
  session        DkgSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  user           User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([sessionId, userId])
  @@index([sessionId])
}

model DkgComplaint {
  id         String             @id @default(cuid())
  sessionId  String
  accuserId  String
  accusedId  String
  reason     String             @default("")
  payload    Json
  status     DkgComplaintStatus @default(OPEN)
  createdAt  DateTime           @default(now())
  resolvedAt DateTime?
  accused    User               @relation("complaintsAccused", fields: [accusedId], references: [id], onDelete: Cascade)
  accuser    User               @relation("complaintsAccuser", fields: [accuserId], references: [id], onDelete: Cascade)
  session    DkgSession         @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId, status])
}

model DkgRecoverySession {
  id               String                   @id @default(cuid())
  createdAt        DateTime                 @default(now())
  updatedAt        DateTime                 @updatedAt
  sourceSessionId  String
  qHash            String
  n                Int
  t                Int
  epoch            String
  requesterUserId  String
  requesterPubKey  String
  status           DkgRecoveryStatus        @default(OPEN)
  resultCiphertext String?
  resultMeta       String?
  participants     DkgRecoveryParticipant[]
  requester        User                     @relation("DkgRecoverySessionUser", fields: [requesterUserId], references: [id], onDelete: Cascade)
  sourceSession    DkgSession               @relation("DkgRecoverySessionDkgSession", fields: [sourceSessionId], references: [id], onDelete: Cascade)
  shares           DkgRecoveryShare[]

  @@index([sourceSessionId, status, createdAt])
}

model DkgRecoveryParticipant {
  id           String             @id @default(cuid())
  joinedAt     DateTime           @default(now())
  recoveryId   String
  userId       String
  e2ePublicKey String?
  recovery     DkgRecoverySession @relation(fields: [recoveryId], references: [id], onDelete: Cascade)
  user         User               @relation("DkgRecoveryParticipantUser", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([recoveryId, userId])
  @@index([recoveryId])
}

model DkgRecoveryShare {
  id         String             @id @default(cuid())
  createdAt  DateTime           @default(now())
  recoveryId String
  fromUserId String
  s_i_hex    String
  proofOk    Boolean            @default(false)
  note       String             @default("")
  fromUser   User               @relation("DkgRecoveryShareUser", fields: [fromUserId], references: [id], onDelete: Cascade)
  recovery   DkgRecoverySession @relation(fields: [recoveryId], references: [id], onDelete: Cascade)

  @@unique([recoveryId, fromUserId])
  @@index([recoveryId])
}

model players_fifa {
  playerId       BigInt   @id @map("player_id")
  age            Float?
  date_of_birth  String?
  first_name     String?

  // внешний ключ может быть пустым, поэтому Int?
  teamId         Int?     @map("team_id")
  team           teams?   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  shirt_number    BigInt?
  position        String?
  full_name       String?
  last_name       String?
  fifa_goals      BigInt?
  fifa_physic     BigInt?
  height          BigInt?
  gk_skill        BigInt?
  rb_skill        BigInt?
  cb_skill        BigInt?
  lb_skill        BigInt?
  rwb_skill       BigInt?
  dm_skill        BigInt?
  lwb_skill       BigInt?
  rm_skill        BigInt?
  cm_skill        BigInt?
  lm_skill        BigInt?
  rw_skill        BigInt?
  am_skill        BigInt?
  lw_skill        BigInt?
  st_skill        BigInt?
  stamina         BigInt?
  defending       BigInt?
  shooting        BigInt?
  pass            BigInt?
  goalkeeper_save BigInt?

  @@map("players_fifa")
}

model teams {
  id    Int      @id @default(autoincrement())
  title String?
  liga  BigInt?

  squad players_fifa[]

  @@map("teams")
}



enum RecoveryStatus {
  PENDING
  DONE
  CANCELED
}

enum ShareStatus {
  ACTIVE
  USED
  EXPIRED
}

enum DocumentStatus {
  NOTECRYPT
  ECRYPT
}

enum ShamirSessionStatus {
  CUSTOM
  ASYMMETRIC
}

enum Sex {
  MALE
  FEMALE
}

enum DkgSessionStatus {
  LOBBY
  ROUND1
  ROUND2
  ROUND3
  FINAL
  ABORTED
}

enum DkgShareDelivery {
  SENT
  DELIVERED
  READ
  REJECTED
}

enum DkgComplaintStatus {
  OPEN
  RESOLVED
  REJECTED
}

enum DkgRecoveryStatus {
  OPEN
  VERIFYING
  DONE
  FAILED
}

enum MatchStatus {
  scheduled
  finished
}

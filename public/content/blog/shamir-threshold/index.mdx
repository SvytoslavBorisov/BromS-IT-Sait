---
title: "Как поделить секрет: простая (k, n) схема Шамира"
description: "Перевод ключевого фрагмента статьи А. Шамира (CACM, 1979) плюс понятные формулы и минимальная реализация на Python."
date: "2025-08-23"
tags:
  - Криптография
  - Пороговые схемы
  - Shamir Secret Sharing
  - Интерполяция Лагранжа
cover: "/blog/shamir-threshold/cover.png"
license: "© Автор перевода, 2025. Non-commercial."
source:
  title: "Adi Shamir — How to Share a Secret (CACM, 1979)"
  doi: "10.1145/359168.359176"
  url: "https://doi.org/10.1145/359168.359176"
  type: "translation"
---

## Пороговые схемы в группах «взаимно подозрительных»

Пороговые схемы особенно хорошо подходят для ситуаций, когда группе людей с конфликтующими интересами необходимо сотрудничать. Идеально — строить взаимодействие на взаимном согласии, но право вето, которое даёт требование единогласия, может парализовать деятельность группы. Правильно выбирая параметры k и n, можно дать достаточно большему большинству право на действие, сохраняя у достаточно крупного меньшинства возможность его заблокировать.

# 2. Простая (k, n) пороговая схема

Идея основана на полиномиальной интерполяции: по заданным k точкам (xi, yi) с попарно различными xi существует ровно один многочлен q(x) степени k-1, для которого q(xi) = yi для всех i. Считаем, что данные D — это число. Чтобы разделить D на n частей, выбираем случайный многочлен степени k-1:

`q(x) = a0 + a1*x + ... + a_{k-1}*x^{k-1}, где a0 = D`

и вычисляем n значений:

`D1 = q(1), D2 = q(2), ..., Dn = q(n)` (все операции далее по модулю p).

По любым k из этих пар (i, Di) можно восстановить коэффициенты q(x) интерполяцией и затем получить секрет как `q(0)`. Знание лишь k-1 значений недостаточно для вычисления D.

Чтобы формально обосновать нулевое раскрытие при k-1 частях, работаем в поле по модулю простого p. Берём p больше, чем и D, и n; коэффициенты `a1..a_{k-1}` выбираются равновероятно из `0..p-1`, значения `Di = q(i) mod p`. Пусть противнику известны k-1 частей. Для каждого кандидата `D'` из `0..p-1` существует единственный многочлен `q'(x)` степени `k-1`, который проходит через известные точки и удовлетворяет `q'(0) = D'`. Эти p вариантов равновероятны, значит противник не узнаёт ничего о настоящем D.

Эффективные алгоритмы интерполяции имеют сложность `O(n log^2 n)`, но даже квадратичные приемлемы. Если D велик, его разбивают на блоки и применяют схему к каждому блоку отдельно. Минимально допустимый модуль p должен быть больше n (нужны разные аргументы x), на практике берут большое простое.

## Свойства схемы

1) Размер каждой доли не больше размера исходных данных (в пределах выбранного p).

2) При фиксированном k доли можно динамически добавлять и удалять, участники могут приходить и уходить.

3) Доли можно перевыпускать без смены секрета D: генерируется новый случайный q(x) с тем же свободным членом `a0 = D`. Старые слитые доли не суммируются в угрозу.

4) Можно строить иерархии полномочий: выдать президенту три разных значения q(x), каждому вице‑президенту по два, каждому руководителю по одному — получится (3, n)‑порог: подпишут либо любые трое руководителей, либо двое, один из которых вице‑президент, либо один президент.

## Лагранжевое восстановление в точке x=0 (без LaTeX)

Пусть есть k попарно различных пар `(xi, yi)` по модулю p.

```
q(0) = sum_{i=1..k} yi * Li
Li   = product_{j=1..k, j!=i} [ (-xj) * inv(xi - xj mod p) ]  (всё по модулю p)
```

Где `inv(z)` — мультипликативная обратная по модулю p (для простого p это `z^(p-2) mod p`). Делений в формулах нет — только умножение и взятие обратного.

## Python: минимальная реализация Shamir (GF(p))

Код ниже самодостаточный: генерация долей и восстановление из любой k‑подвыборки. Без внешних зависимостей. По умолчанию `p = 2^521 - 1` (большое простое).

```python
from __future__ import annotations
from dataclasses import dataclass
from secrets import randbelow
from typing import List

# Большое простое (Мерсенна), p > n и p > secret
P = (1 << 521) - 1

@dataclass(frozen=True)
class Share:
    x: int  # уникальный идентификатор 1..n
    y: int  # q(x) mod p

def _mod_inv(a: int, p: int) -> int:
    """Обратный по модулю p, где p — простое."""
    return pow(a % p, p - 2, p)

def _eval_poly(coeffs: List[int], x: int, p: int) -> int:
    """Значение q(x) по Горнеру; coeffs[0] = a0 = секрет."""
    res = 0
    for a in reversed(coeffs):  # a_{k-1} ... a0
        res = (res * x + a) % p
    return res

def split_secret(secret: int, k: int, n: int, p: int = P) -> List[Share]:
    """
    Возвращает n долей для секрета secret при пороге k.
    Требования: 0 <= secret < p и n < p.
    """
    if not (0 <= secret < p):
        raise ValueError("secret must be in [0, p)")
    if not (1 <= k <= n < p):
        raise ValueError("require 1 <= k <= n < p")

    # Случайные коэффициенты a1..a_{k-1}; a0 = secret
    coeffs = [secret] + [randbelow(p) for _ in range(k - 1)]
    return [Share(x=i, y=_eval_poly(coeffs, i, p)) for i in range(1, n + 1)]

def recover_secret(shares: List[Share], p: int = P) -> int:
    """
    Восстанавливает q(0) по любой k-подвыборке долей.
    """
    if not shares:
        raise ValueError("need at least one share")

    xs = [s.x for s in shares]
    ys = [s.y for s in shares]
    if len(set(xs)) != len(xs):
        raise ValueError("duplicate x in shares")

    total = 0
    k = len(shares)
    for i in range(k):
        xi, yi = xs[i], ys[i]
        num = 1
        den = 1
        for j in range(k):
            if i == j:
                continue
            xj = xs[j]
            num = (num * (-xj)) % p
            den = (den * (xi - xj)) % p
        li0 = (num * _mod_inv(den, p)) % p
        total = (total + yi * li0) % p
    return total

if __name__ == "__main__":
    secret = 123456789012345678901234567890
    k, n = 3, 5
    shares = split_secret(secret, k, n)
    print("SHARES:", shares)

    subset = [shares[i] for i in (0, 2, 4)]  # любые 3 доли
    rec = recover_secret(subset)
    print("RECOVERED:", rec)
    assert rec == secret
```

---
title: "Как поделить секрет: простая (k, n) схема Шамира"
description: "Перевод ключевого фрагмента статьи А. Шамира (CACM, 1979) плюс понятные формулы и минимальная реализация на Python."
date: "2025-08-23"
tags:
  - Криптография
  - Пороговые схемы
  - Shamir Secret Sharing
  - Интерполяция Лагранжа
cover: "/content/blog/shamir-threshold/cover.png"
license: "© Автор перевода, 2025. Non-commercial."
source:
  title: "Adi Shamir — How to Share a Secret (CACM, 1979)"
  doi: "10.1145/359168.359176"
  url: "https://doi.org/10.1145/359168.359176"
  type: "translation"
---

\documentclass[a4paper,12pt]{article}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath,amssymb}
\usepackage{geometry}
\geometry{margin=2.5cm}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{listings}

% Настройки выделения заголовков
\titleformat{\section}{\large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection}{1em}{}

% Настройки листингов (Python)
\lstdefinestyle{py}{
  language=Python,
  basicstyle=\ttfamily\small,
  keywordstyle=\bfseries\color{teal!60!black},
  commentstyle=\itshape\color{gray!70!black},
  stringstyle=\color{orange!60!black},
  showstringspaces=false,
  columns=fullflexible,
  breaklines=true,
  frame=single,
  framerule=0.4pt,
  rulecolor=\color{gray!40},
  backgroundcolor=\color{gray!5},
  tabsize=2
}

\title{Как поделить секрет}
\author{Ади Шамир \\ Массачусетский технологический институт}
\date{Ноябрь 1979}

\begin{document}

\begin{center}
{\LARGE \textbf{Как поделить секрет: простая $(k, n)$ схема Шамира}}\\[0.5em]
\emph{Перевод ключевого фрагмента статьи А. Шамира (CACM, 1979) плюс понятные формулы и минимальная реализация на Python.}\\[0.5em]
\small Дата: 23 августа 2025 \quad
Теги: Криптография; Пороговые схемы; Shamir Secret Sharing; Интерполяция Лагранжа.\\[0.25em]
\small Лицензия: © Автор перевода, 2025. Non-commercial.\\[0.25em]
\small Источник: Adi Shamir — How to Share a Secret (CACM, 1979), DOI: \href{https://doi.org/10.1145/359168.359176}{10.1145/359168.359176}.
\end{center}

\vspace{1em}

\section*{Аннотация}
В этой статье мы показываем, как разделить данные $D$ на $n$ частей так,
чтобы $D$ можно было легко восстановить из любых $k$ частей, но даже полное
знание $k-1$ частей не раскрывало абсолютно никакой информации о $D$.
Эта техника позволяет строить устойчивые схемы управления ключами для
криптографических систем, которые могут работать безопасно и надёжно даже тогда,
когда несчастные случаи уничтожают половину частей, а утечки раскрывают все,
кроме одной, из оставшихся частей.

\textbf{Ключевые слова:} криптография, управление ключами, интерполяция

\section{Введение}

В \cite{liu1968} Лю рассматривает следующую задачу:

\emph{Одиннадцать учёных работают над секретным проектом. Они хотят
запереть документы в шкафу так, чтобы шкаф можно было открыть тогда и только тогда,
когда присутствуют шесть или более учёных. Какое минимальное число замков нужно?
Какое минимальное число ключей от замков должен носить каждый учёный?}

Нетрудно показать, что минимальное решение требует 462 замка и 252 ключа
на учёного. Эти числа явно непрактичны и становятся экспоненциально хуже,
когда число учёных увеличивается.

В этой статье мы обобщаем задачу на случай, когда секретом являются
некоторые данные $D$ (например, комбинация от сейфа), и разрешаются
немеханические решения (которые оперируют этими данными).
Наша цель --- разделить $D$ на $n$ частей $D_1, \ldots, D_n$ так, чтобы:

\begin{enumerate}
\item Знание любых $k$ или более частей $D_i$ делает $D$ легко вычислимым;
\item Знание любых $k-1$ или менее частей $D_i$ оставляет $D$ полностью
неопределённым (в том смысле, что все его возможные значения равновероятны).
\end{enumerate}

Такая схема называется $(k,n)$-пороговой схемой.
Эффективные пороговые схемы могут быть очень полезны в управлении
криптографическими ключами.

Чтобы защитить данные, мы можем их зашифровать, но для защиты самого
ключа шифрования нужен иной метод (дополнительное шифрование не решает проблему,
а лишь усложняет её). Самая надёжная схема управления ключами хранит ключ в одном
хорошо охраняемом месте (компьютер, человеческий мозг или сейф). Такая схема
ненадёжна, так как одна случайность (поломка компьютера, внезапная смерть или
саботаж) может сделать информацию недоступной. Очевидное решение --- хранить
несколько копий ключа в разных местах, но это увеличивает риск утечек
(взлом, предательство или ошибки). Используя $(k,n)$-пороговую схему с $n = 2k-1$,
мы получаем очень устойчивую систему: исходный ключ можно восстановить даже если
$\lfloor n/2 \rfloor = k-1$ частей уничтожены, но противник не может восстановить
ключ даже если утечки раскрыли $\lfloor n/2 \rfloor = k-1$ частей.

В других приложениях компромисс заключается не между секретностью и надёжностью,
а между безопасностью и удобством использования. Рассмотрим, например, компанию,
которая подписывает все свои чеки цифровой подписью (см. RSA \cite{rsa1978}).
Если каждый руководитель имеет копию секретного ключа подписи компании,
система удобна, но уязвима. Если требуется согласие всех руководителей для
подписания, система безопасна, но крайне неудобна. Стандартное решение требует
минимум трёх подписей на чеке, и его легко реализовать с помощью $(3,n)$-схемы.
Каждому руководителю выдают магнитную карту с одной частью $D_i$, и устройство
генерации подписи принимает любые три карты для создания (и последующего уничтожения)
временной копии настоящего ключа $D$. Устройство не хранит секретной информации,
и потому его не нужно защищать от осмотра. Неверный руководитель должен иметь
как минимум двух сообщников, чтобы подделать подпись компании.

Пороговые схемы идеально подходят для приложений, где группа недоверяющих друг другу
людей с противоречивыми интересами должна сотрудничать. Идеально, если бы
сотрудничество основывалось на взаимном согласии, но право вето может парализовать
работу группы. Правильным выбором параметров $k$ и $n$ можно дать любой достаточно
большой группе большинство для принятия решений, сохраняя у меньшинства возможность
заблокировать их.

\section{Простая $(k,n)$-пороговая схема}

Наша схема основана на полиномиальной интерполяции: имея $k$ точек на плоскости
$(x_1, y_1), \ldots, (x_k, y_k)$ с различными $x_i$, существует единственный
полином $q(x)$ степени $k-1$, такой что $q(x_i) = y_i$ для всех $i$.
Без потери общности предположим, что данные $D$ являются числом.
Чтобы разделить их на части $D_i$, мы выбираем случайный полином степени $k-1$

\begin{equation*}
q(x) = a_0 + a_1 x + \ldots + a_{k-1}x^{k-1}, \quad a_0 = D,
\end{equation*}

и вычисляем:

\begin{equation*}
D_1 = q(1), \quad D_2 = q(2), \ldots, D_n = q(n).
\end{equation*}

Имея любые $k$ значений $D_i$ (вместе с их индексами), можно восстановить коэффициенты
$q(x)$ методом интерполяции и затем найти $D = q(0)$. Однако знание любых $k-1$
значений недостаточно для вычисления $D$.

Чтобы сделать утверждение точным, используем модульную арифметику вместо действительных чисел.
Множество целых по модулю простого $p$ образует поле, в котором возможна интерполяция.
Для целых данных $D$ выбираем простое $p > \max(D, n)$. Коэффициенты
$a_1, \ldots, a_{k-1}$ выбираются случайно и равновероятно из $[0, p)$, а значения
$D_i$ вычисляются по модулю $p$.

Теперь предположим, что противнику известны $k-1$ частей. Для любого кандидата $D'$ из $[0,p)$
он может построить единственный полином $q'(x)$ степени $k-1$, такой что $q'(0) = D'$ и
$q'(i) = D_i$ для известных $k-1$ аргументов. Все $p$ возможных полиномов равновероятны,
и потому противник не может узнать истинное значение $D$.

Существуют эффективные алгоритмы $O(n \log^2 n)$ для вычисления и интерполяции полиномов
\cite{aho1974,knuth1969}, но даже простые квадратичные алгоритмы достаточно быстры
для практического использования. Если число $D$ длинное, полезно разбивать его на блоки бит,
чтобы избежать многоточных операций. Длина блока ограничена: минимальное $p$ равно $n+1$.
Однако это не проблема: модуль в 16 бит достаточно для $64{,}000$ частей.

\subsection*{Свойства схемы}

Некоторые полезные свойства этой $(k,n)$-схемы (в сравнении с механическими замками и ключами):

\begin{enumerate}
\item Размер каждой части не превышает размер исходных данных;
\item При фиксированном $k$ части $D_i$ можно динамически добавлять или удалять
(например, при приходе или уходе сотрудников);
\item Можно менять части $D_i$, не меняя исходные данные $D$, просто выбрав новый полином
с тем же свободным членом. Это повышает безопасность: раскрытые части не могут
накапливаться между разными версиями;
\item Используя кортежи значений полинома как части $D_i$, можно построить иерархическую схему.
Например, президент компании получает три значения $q(x)$, вице-президент --- два,
руководитель --- одно. Тогда $(3,n)$-схема позволяет подписывать чеки любыми тремя
руководителями, или двумя, включая вице-президента, или одним президентом.
\end{enumerate}

Другая, менее эффективная схема была недавно предложена Г.Р. Блэйкли \cite{blakley1979}.

\section*{Список литературы}

\begin{thebibliography}{9}

\bibitem{aho1974}
Ахо, А., Хопкрофт, Дж., Улльман, Дж. \textit{Проектирование и анализ алгоритмов}.
Аддисон-Уэсли, Рединг, Массачусетс, 1974.

\bibitem{blakley1979}
Блэйкли, Г.Р. Защита криптографических ключей.
Proc. AFIPS 1979 NCC, Т. 48, Арлингтон, Вирджиния, июнь 1979, стр. 313--317.

\bibitem{knuth1969}
Кнут, Д. \textit{Искусство программирования, т. 2: Получисленные алгоритмы}.
Аддисон-Уэсли, Рединг, Массачусетс, 1969.

\bibitem{liu1968}
Лю, Ч.-Л. \textit{Введение в комбинаторную математику}. Макгроу-Хилл,
Нью-Йорк, 1968.

\bibitem{rsa1978}
Ривест, Р., Шамир, А., Адельман, Л. Метод получения цифровых подписей и
криптосистем с открытым ключом. \textit{Comm. ACM}, 21(2):120--126, февраль 1978.

\end{thebibliography}

\end{document}

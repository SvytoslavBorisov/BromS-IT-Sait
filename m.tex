\textbf{Схема разделения секрета на основе хеширования}

M. Andrecut

7 февраля 2023 г.

Калгари, Альберта, Канада

mircea.andrecut@gmail.com

\textbf{Аннотация.}
Мы предлагаем адаптивную пороговую многосекретную схему разделения секрета, основанную исключительно на криптографически стойких хеш-функциях. Мы показываем, что предлагаемая схема также является: совершенной, идеальной, проверяемой и проактивной. Кроме того, предлагаемая схема обладает низкой вычислительной сложностью по сравнению с наиболее распространёнными схемами, работающими над конечными полями.

\textbf{Ключевые слова:} схема разделения секрета, хеш-функции.

\section*{1 \quad Введение}

Схема разделения секрета (SSS) — это метод распределения секрета \(S\), например ключа шифрования, между группой из \(n\) участников~\cite{1}. В SSS распорядитель \(D\) выделяет долю \(s_i\) секрета каждому участнику, \(i=0,1,\ldots,n-1\), так, что секрет может быть восстановлен только при объединении долей; следовательно, отдельные доли поодиночке бесполезны~\cite{2}. SSS используются для хранения и предоставления доступа к особо чувствительной и важной информации, с применениями в: облачных вычислениях, военной сфере, разведке, банковском деле, здравоохранении, сенсорных сетях и т.\,д.

Аддитивная SSS, вероятно, является самым простым методом и предполагает, что секрет \(S\) может быть разбит на случайно выбранные доли, являющиеся элементами абелевой группы, \(s_i \in (G,+)\), \(i=0,1,\ldots,n-1\), так что
\[
S=\sum_{i=0}^{n-1} s_i .
\]
В этой схеме секрет может быть восстановлен только путём сложения всех долей, поскольку любое подмножество долей не раскрывает ничего о \(S\). Важным расширением является пороговая SSS, или \((t,n)\)-SSS, где для восстановления секрета требуется пороговое число \(t\) долей, меньшее общего числа долей \(n\), \(t\le n\). Это повышает устойчивость SSS и предотвращает отказ в восстановлении секрета в случае недоступности одного или нескольких участников.

Первые \((t,n)\)-SSS были независимо предложены Ади Шамиром~\cite{3} и Джорджем Блэйкли~\cite{4} в 1979 году. Например, схема Шамира основана на полиномиальной интерполяции и наблюдении, что для однозначного задания полинома порядка \(t\) требуется \(t+1\) различных точек. Секрет \(S\) соответствует первому коэффициенту полинома, а остальные коэффициенты выбираются случайно. Значения полинома в различных точках \(x_i\), \(i=0,1,\ldots,n-1\), затем распределяются между \(n\) участниками в качестве долей. Полином может быть восстановлен методом интерполяции Лагранжа по \(t\) или большему числу долей, и, следовательно, можно восстановить секрет, соответствующий первому коэффициенту.

Начиная с их появления, было предложено множество других SSS-схем~\cite{5}. Однако большинство из них малопригодны для практических приложений и в той или иной степени страдают от следующих проблем:

\begin{itemize}
\item отсутствие практических методов верификации, требующее честности со стороны распорядителя и/или участников;
\item обычно делится только один секрет, без возможности делить несколько секретов;
\item изменение порога или секрета требует полной перерасчётной процедуры и перераспределения долей;
\item высокая вычислительная сложность, поскольку операции выполняются над конечными полями Галуа \(GF(p)\), где \(p\) — большое простое число;
\item некоторые обобщённые схемы требуют экспоненциально большого числа долей~\cite{6}.
\end{itemize}

Здесь мы предлагаем адаптивную пороговую SSS, основанную исключительно на криптографически стойких хеш-функциях, и показываем, что такой подход позволяет успешно устранить приведённые выше проблемы.

\section*{2 \quad Предварительные сведения}

\subsection*{2.1 \quad Односторонние функции}

\textbf{Определение 1} (\textit{Односторонняя функция}). Односторонняя функция легко вычисляется на любом входе, но чрезвычайно трудно обращается.

Таким образом, можно без труда вычислить \(f(x)\) для любого заданного \(x\), но практически «невозможно» вычислить \(x\) по данному \(f(x)\). Хотя существование односторонних функций не доказано строго математически, они часто используются как абстрактный элемент в криптографии, и можно показать, что им очень хорошо аппроксимируют криптографически стойкие хеш-функции~\cite{2}.

\subsection*{2.2 \quad Хеш-функции}

Криптографическая хеш-функция (односторонняя) предназначена для преобразования входных сообщений произвольной длины в выходные хеш-значения фиксированной длины; её можно определить следующим образом~\cite{7}:

\textbf{Определение 2} (\textit{Хеш-функция}). Функция
\[
h:\{0,1\}^{\ast}\rightarrow \{0,1\}^{\ell},
\]
которая принимает двоичную строку \(x\) произвольной конечной длины (называемую \emph{сообщением}) и выдаёт двоичную строку фиксированной длины \(h(x)\) (называемую \emph{хешем}) длины \(\ell\), является хеш-функцией, если она удовлетворяет следующим свойствам:
\begin{enumerate}
\item \textbf{Лёгкость вычисления:} вычисляет хеш-значение для любой заданной двоичной строки;
\item \textbf{Детерминированность вычисления:} хеш-функция даёт один и тот же результат для одних и тех же входных данных; любое изменение входной двоичной строки вызывает изменение хеш-значения;
\item \textbf{Устойчивость к первообразу (preimage resistance):} невозможно обратить, т.\,е. сгенерировать двоичную строку, имеющую заданное хеш-значение;
\item \textbf{Устойчивость ко второму первообразу (second preimage resistance):} для данной двоичной строки и её хеша невозможно найти другую двоичную строку с тем же хеш-значением;
\item \textbf{Устойчивость к коллизиям (collision resistance):} невозможно найти две различные двоичные строки-сообщения с одинаковым хеш-значением.
\end{enumerate}

Приведённое выше определение описывает «идеальную» хеш-функцию. В реальности все существующие хеш-функции уязвимы для универсальной атаки, основанной на «парадоксе дней рождения», что означает: для \(\ell\)-битной хеш-функции и \(2^{\ell/2}\) различных сообщений коллизия возникает с ненезначительно малой вероятностью. Следовательно, чем больше битовая длина хеш-функции, тем выше её стойкость к коллизиям. Что касается первообраза и второго первообраза, в настоящее время лучшая универсальная атака на поиск первообраза сводится к полному перебору по множеству всех возможных сообщений (которые в данном случае имеют хеш-значения длины \(\ell\)), со стоимостью \(2^{\ell}\).

Типичными хеш-функциями являются стандартные криптографические хеш-функции SHA-256 и SHA-512, опубликованные NIST~\cite{6}. Например, при использовании функции SHA-512, независимо от размеров входных данных, выход всегда имеет фиксированную длину 512 бит. Это свойство становится критически важным при работе с большими данными и транзакциями, поскольку вместо запоминания самих входных данных можно запомнить лишь хеш-значение. Таким образом, используя криптографическую хеш-функцию, легко проверить, что заданные данные отображаются в заданный хеш, но если входные данные неизвестны, «невозможно» восстановить данные (или любые эквивалентные альтернативы), располагая только хеш-значением.

Эти свойства хеш-функций используются для обеспечения безопасности предлагаемой SSS. Далее, если не оговорено иное, мы рассматриваем криптографически стойкие хеш-функции длиной не менее 512 бит, например SHA-512.

\subsection*{2.3 \quad Структура доступа}

В \((t,n)\)-SSS предполагается, что имеется \(n\) участников \(P=\{P_0,P_1,\ldots,P_{n-1}\}\), и для восстановления секрета \(S\) требуется минимальное число \(t\) участников.

\textbf{Определение 3} (\textit{Авторизованное подмножество}). Авторизованное подмножество — это группа участников, способная восстановить секрет при объединении своих долей. Соответственно, неавторизованное подмножество — любая группа участников, которая не может восстановить секрет.

\textbf{Определение 4} (\textit{Структура доступа}). Множество всех авторизованных подмножеств определяет структуру доступа \(Q\).

\textbf{Определение 5} (\textit{Минимальное авторизованное подмножество}). \(A\in Q\) называется минимальным авторизованным подмножеством, если для любого \(B\subset A\) выполняется \(B\notin Q\).

\textbf{Определение 6} (\textit{Базис структуры доступа}). Базис \(\tilde{Q}\) структуры доступа \(Q\) состоит из всех минимальных авторизованных подмножеств.

\subsection*{2.4 \quad Совершенная и идеальная SSS}

\textbf{Определение 7} (\textit{Совершенная SSS}). SSS, не допускающая раскрытия частичной информации о долях.

\textbf{Определение 8} (\textit{Идеальная SSS}). SSS, в которой доли и секрет принадлежат одному и тому же домену и имеют одинаковый размер.

\subsection*{2.5 \quad Проверяемая SSS}

\textbf{Определение 9} (\textit{Проверяемая SSS}). SSS является проверяемой, если она предоставляет метод проверки корректности долей.

Проверяемая SSS должна уметь выявлять потенциально злонамеренные действия как со стороны распорядителя, так и со стороны участников. Это означает, что участники должны иметь возможность проверять корректность своих долей и отвергать потенциально ложные доли, предоставленные злонамеренным распорядителем. Взаимно, на этапе восстановления секрета распорядитель также должен иметь возможность проверять доли, предоставленные потенциально злонамеренными участниками.

\subsection*{2.6 \quad Проактивная SSS}

\textbf{Определение 10} (\textit{Проактивная SSS}). SSS является проактивной, если она способна периодически выполнять сброс и перераспределение новых долей, с необходимостью или без необходимости изменения секрета.

Цель проактивной SSS — сделать бесполезной любую информацию, собранную противником между последовательными сбросами долей.

\section*{3 \quad Предлагаемая SSS}

\subsection*{3.1 \quad Основная постановка}

Основные элементы SSS таковы:
\begin{itemize}
\item \(n>0\) участников: \(P=\{P_0, P_1, \ldots, P_{n-1}\}\).
\item \(m\ge 1\) секрет: \(S=\{S^0, S^1, \ldots, S^{m-1}\}\).
\item распорядитель \(D\) (доверенная сущность), который подготавливает и распределяет доли между участниками;
\item криптографически стойкая хеш-функция \(h()\), которая общедоступна.
\end{itemize}

Проблема, которую мы решаем, — построить совершенную, идеальную, проверяемую и проактивную SSS, обеспечивающую защищённую структуру доступа к \(m\) секретам для группы из \(n\) участников, с потенциально модифицируемым и адаптируемым порогом \(0<t\le n\).

\subsection*{3.2 \quad Этап кодирования}

Здесь мы предполагаем, что \(m\) секретов хранятся в \(m\) защищённых «хранилищах», и фактически должны быть разделены между участниками только секретные ключи доступа («пароли») к этим хранилищам. Другой эквивалентный вариант — зашифровать секреты с помощью симметричного алгоритма (например, AES), используя эти секретные ключи.

Обозначим секретные ключи так: \(k_j\), \(j=0,1,\ldots,m-1\). Таким образом, нам нужно разработать метод, способный генерировать ключи, используя \(t\) различных долей секрета. Сначала заметим, что каждый секрет \(S^j\) можно легко идентифицировать, сопоставив ему собственное хеш-значение:
\[
j \longleftrightarrow q_j = h(S^j), \qquad j=0,1,\ldots,m-1.
\tag{1}
\]

Предположим, что «базис» долей состоит из множества из \(t+1\) случайно сгенерированных битовых строк длины \(\ell'\):
\[
s^{\ast}=\{\, s^{\ast}_b \mid s^{\ast}_b \in \{0,1\}^{\ell'} ,\ b=0,1,\ldots,t \,\}.
\tag{2}
\]

Любые две доли можно упорядочить с помощью оператора \(<\); будем говорить, что кортеж \((s^{\ast}_i, s^{\ast}_j)\) упорядочен, если \(s^{\ast}_i < s^{\ast}_j\). Соответственно, любой список попарно различных долей может быть упорядочен функцией \(\varphi()\). Упорядоченный список долей может быть конкатенирован в строку функцией \(\gamma()\). Здесь мы используем \(\,\|\,\) в качестве оператора конкатенации двух строк, \(a\|b \equiv ab\), а \(\gamma()\) — как функцию конкатенации, применённую к списку: \(\gamma([a,b,c])=abc\).

Для повышения гибкости также предполагаем, что распорядитель является одним из участников и выделил себе собственную долю из базисного множества \(s^{\ast}\), например \(s^{\ast}_0\). Остальные участники делятся на \(t\) групп \(\Gamma_b\), \(b=1,\ldots,t\), причём в каждой группе имеется по крайней мере один участник \(n_b \ge 1\), так что \(n=\sum_{b=1}^{t} n_b\). Каждый участник такой группы \(\Gamma_b\) получает соответствующую отличающуюся долю \(s^{b}_i\) из базисного множества \(s^{\ast}\).

Генерация и восстановление секретных ключей будут требовать, чтобы в процессе участвовал по меньшей мере один член из каждой группы. Это требование одновременно определяет авторизованное подмножество. Легко видеть, что всего существует \(\prod_{b=1}^{t} n_b\) минимальных авторизованных подмножеств. Следовательно, любое авторизованное подмножество участников фактически должно обладать базисным набором \(s^{\ast}\), чтобы иметь возможность восстановить секретные ключи.

Обозначим
\[
\xi=\gamma(\varphi(s^{\ast})) ,
\tag{3}
\]
то есть строку, полученную конкатенацией упорядоченного списка долей из базисного набора. Каждый секретный ключ \(k_j\) определяется как хеш-значение конкатенации хеш-значения \(q_j\) секрета \(S^j\) со строкой \(\xi\), полученной конкатенацией упорядоченного базисного набора \(s^{\ast}\), так что можно однозначно идентифицировать, какой ключ предстоит построить или восстановить:
\[
j \longleftrightarrow q_j \longleftrightarrow h(q_j\| \xi)=k_j,\qquad j=0,1,\ldots,m-1 .
\tag{4}
\]

Важно отметить, что если длина \(\ell'\) долей \(s^{\ast}_b\) и длина \(\ell\) секретных ключей \(k_j\) совпадают, \(\ell'=\ell\), то SSS становится совершенной и идеальной. Также важно, что распорядитель может быть «нейтральным» в этой схеме, просто установив свою долю равной пустой строке, чтобы она не влияла на вычисления секретных ключей.

\subsection*{3.3 \quad Этап распределения}

После генерации долей и вычисления секретных ключей доли могут быть распределены участникам. В силу односторонности хеш-функции из хеш-значений долей нельзя узнать ничего о самих долях. Поэтому распорядитель может также вычислить хеш-значение каждой доли из базисного набора, \(g_b=h(s^{\ast}_b)\), а затем опубликовать множество полученных хешей:
\[
g^{\ast}=\{\, g_b \mid g_b=h(s^{\ast}_b),\ b=0,1,\ldots,t \,\}.
\tag{5}
\]

Аналогично, по хеш-значениям секретов нельзя узнать ничего о самих секретах. Следовательно, распорядитель мог бы опубликовать и хеш-значения секретов. Однако, поскольку секретный ключ \(k_j\) также зависит от хеш-значения секрета \(q_j=h(S^j)\), мы предпочитаем не раскрывать это хеш-значение, так как оно содержит частичную информацию о ключе. Вместо этого распорядитель должен раскрывать второе хеш-значение
\[
r_j=h(h(S^j)):
\qquad
r^{\ast}=\{\, r_j \mid r_j=h(h(S^j)),\ j=0,1,\ldots,m-1 \,\},
\tag{6}
\]
которое не предоставляет полезной информации ни о секрете \(S^j\), ни о его первом хеш-значении \(h(S^j)\).

Цель этапа публикации — сделать SSS проверяемой. Таким образом любой участник может удостовериться, что получил корректную долю от распорядителя, просто проверив, входит ли хеш его доли \(h(s_i)\) в опубликованное множество \(g^{\ast}\), или нет. Поэтому \(g^{\ast}\) можно называть «набором проверки долей». Кроме того, любой участник может проверить, входит ли второе хеш-значение восстановленного секрета в «набор проверки секретов» \(r^{\ast}\), и, следовательно, решить, является ли секрет корректным.

\subsection*{3.4 \quad Этап восстановления (Recovery phase)}

Любое авторизованное подмножество участников может восстановить секрет \(S^{j}\), представив свои доли «комбинатору» (combiner) и индекс \(j\) требуемого секрета. Отметим, что роль комбинатора может выполнять как распорядитель, так и иная доверенная сущность; в обоих случаях SSS работает одинаково. Для простоты будем считать, что и распорядитель, и комбинатор контролируются одной и той же доверенной сущностью. Комбинатор может легко проверить, корректны ли представленные доли, просто проверив, входит ли их хеш в опубликованный верификационный набор \(g^{\ast}\). Затем комбинатор извлекает множество попарно различных долей из списка полученных долей. Число различных долей должно равняться пороговому значению \(t\). Если это так, комбинатор получил требуемый набор базисных долей \(s^{\ast}\) и может вычислить секретный ключ
\[
k_j = h\!\left(q_j \,\|\, \gamma(\varphi(s^{\ast}))\right).
\]
Восстановленный секрет \(S^{j}\) затем передаётся членам авторизованного подмножества, которые могут убедиться, что секрет корректен, проверив, включено ли \(h(h(S^{j}))\) в \(r^{\ast}\), или нет.

\subsection*{3.5 \quad Проактивная фаза (Proactive phase)}

Чтобы помешать противнику узнать что-либо о долях, распорядитель может периодически генерировать новые доли и распределять их между участниками. Заметим, что модификация секретов \(S^{j}\) не требует перерасчёта долей; перерасчёту подлежат только секретные ключи \(k_j\), поскольку они зависят от хеш-значения секрета \(q_j=h(S^{j})\). Такое обновление также можно использовать для изменения порогового значения при необходимости.

Распорядитель может также предпринять немедленную защитную меру, просто «обновив» лишь собственную базисную долю или лишь некоторые из базисных долей и уведомив только затронутых участников. Кроме того, распорядитель может отозвать заданную базисную долю, если, например, определённая группа больше не должна иметь доступа. Отзыв, разумеется, уменьшит порог на единицу, но если изначально порог был сравнительно высоким, влияние на SSS будет минимальным.

Простой способ поддерживать разумное пороговое значение — выделить распорядителю больше различных долей, которые также будут считаться базисными. Мы называем их «контролирующими» долями (controlling shares). Другой «адаптивный» способ сохранить то же пороговое значение — заменить отозванную долю контролирующей. Аналогично, при добавлении новой обычной базисной доли распорядитель может отозвать и удалить одну «контролирующую» долю. Этот простой адаптивный механизм создания и уничтожения контролирующих долей можно использовать для поддержания (сохранения) желаемого постоянного порогового значения для SSS.

\subsection*{3.6 \quad Замечание (Observation)}

Чтобы снизить риск раскрытия долей противнику, обмен между распорядителем (комбинатором) и участниками можно проводить с использованием любого стандартного метода шифрования с открытым ключом, такого как RSA или ECC~\cite{1,2}. В этом случае доли шифруются открытыми ключами и расшифровываются закрытыми ключами соответствующих сторон.

Хотя предлагаемая SSS является пороговой схемой \((t,n)\), она функционирует иначе, чем схема Шамира. В схеме Шамира любые \(t\) участников могут восстановить секрет, тогда как в предлагаемой SSS секреты могут быть восстановлены только авторизованными подмножествами участников. Однако минимальное авторизованное множество всё же требует, чтобы по меньшей мере \(t\) участников обладали базисными долями.

\section*{4 \quad Заключение (Conclusion)}

Мы представили пороговую адаптивную многосекретную схему разделения секрета, основанную исключительно на криптографически стойких хеш-функциях. Дополнительно показано, что предлагаемая схема также является: совершенной, идеальной, проверяемой и проактивной. Предлагаемая схема обладает очень низкой вычислительной сложностью и малыми требованиями к хранению данных по сравнению с наиболее распространёнными схемами, работающими над конечными полями.

\section*{References}

[1] D.R. Stinson, \textit{Cryptography Theory and Practice}, 3rd ed., CRC Press, 2006.

[2] J. Katz, Y. Lindell, \textit{Introduction to modern cryptography}, CRC Press, 2008.

[3] A. Shamir, How to share a secret, \textit{Commun. ACM} 22 (11) 612–613 (1979).

[4] G.R. Blakley, Safeguarding cryptographic keys, \textit{Managing Requirements Knowledge, International Workshop (AFIPS)}, IEEE Computer Society, 313–313 (1979).

[5] A. Beimel, Secret-Sharing Schemes: A Survey, \textit{3rd International Conference on Coding and Cryptology (IWCC 2011)}, Qingdao, China, pp. 11–46 (2011).

[6] M. Ito, A. Saito, T. Nishizeki, Secret sharing scheme realizing general access structure, \textit{Electronics and Communications in Japan (Part III: Fundamental Electronic Science)}, vol. 72, no. 9, pp. 56–64 (1989).

[7] NIST, Descriptions of SHA-256, SHA-384, and SHA-512, \url{http://csrc.nist.gov/groups/STM/cavp/documents/shs/sha256-384-512.pdf}.

